{
    "contents" : "# for this script to work, you will need to output two files from Illumima's GenomeStudio software \n# the first file should contain non-normalized, non-background subtracted probe-level data with columns for at least the following: Avg_Signal, Avg_NBeads, BEAD_STD and Detection Pval\n# the second file should contain probe set data for controls\n\n# being by loading the lumi package\n# if using Mouse arrays, change 'Mouse' to 'Mouse' for the mapping and .db packages below\nlibrary(lumi)\nlibrary(lumiMouseIDMapping)\nlibrary(lumiMouseAll.db)\n\n###############################################################################################\n# Read in the GenomeStudio output files using the 'LumiR' and 'addControlData2lumi' functions\n# This will create 'LumiBatch' objects from the control and experimental probe data\n###############################################################################################\nrawData <- lumiR(\"FinalReport_samples_probes_NoNorm_NoBkrnd.txt\", convertNuID = TRUE, sep = NULL, detectionTh = 0.01, na.rm = TRUE, lib = \"lumiMouseIDMapping\")\nrawData\n\n# Read control probe data into a separate LumiBatch and take a look at these controls\nrawData <- addControlData2lumi(\"FinalReport_controls_probes_NoNorm_NoBkrnd.txt\", rawData)\nrawData\ncontrolData <- getControlData(rawData)\ngetControlType(controlData)\nplotStringencyGene(rawData, lib = NULL, slideIndex = NULL, addLegend = TRUE, logMode = TRUE)\nplotControlData(rawData, type = 'HOUSEKEEPING', slideIndex = NULL, logMode = TRUE, new = TRUE)\nplotHousekeepingGene(rawData)\n\n###############################################################################################\n# QC check of data\n###############################################################################################\nsummary(rawData, 'QC')\n\n# choose color scheme for graphs\ncols.ALL <- topo.colors(n=16, alpha=1)\n\nhist(rawData, xlab = \"log2 expression\", main = \"non-normalized data - histograms\")\nboxplot(rawData, ylab = \"non-normalized log2 expression\", main = \"non-normalized data - boxplots\", col=cols.ALL)\n# pairs(rawData)\n# MAplot(rawData)\n\n\n###############################################################################################\n# carry out all preprocessing steps (lumiQ, lumiB, lumiN, lumiT) using the 'lumiExpresso' function which encapsulates all these preprocessing steps\n###############################################################################################\n# options for normalization in Lumi include: \"loess', 'quantile', 'vsn' and the default, which is robust spline normalization ('rsn') which combines the features of quantile and loess\nnormData <- lumiExpresso(rawData, QC.evaluation=TRUE, normalize.param=list(method='rsn'))\n\n\n###############################################################################################\n# repeat the summarization of QC data and graphs on the normalized data\n###############################################################################################\nsummary(normData, 'QC')\nhist(normData, xlab = \"log2 expression\", main = \"non-normalized data - histograms\", col=cols.ALL)\nboxplot(normData, ylab = \"non-normalized log2 expression\", main = \"non-normalized data - boxplots\", col=cols.ALL)\n\n######################################################\n# filter out probes that don't change (low variance)\n# remove duplicate genes based on entrez ID\n# remove coding sequences with no entrezIDs\n######################################################\nlibrary(genefilter)\nfiltered_geneList <- nsFilter(normData, require.entrez=TRUE, remove.dupEntrez=TRUE, var.func=IQR, var.filter=TRUE, var.cutoff=0.5, filterByQuantile=TRUE)\nhead(filtered_geneList)\n# extract the ExpressionSet from this filtered list\nfiltered.eset <- filtered_geneList$eset\nhead(filtered.eset)\n\n# now convert to a datamatrix that will contain only the probes after filtering\nfiltered.matrix <- as.matrix(filtered.eset)\nprobeList <- rownames(filtered.matrix)\nhead(filtered.matrix)\n\n\n###############################################################################################\n# output this filtered data to a table that can be used in Excel or other programs\n# This file contains genes after normalization and filtering\n###############################################################################################\n# first need to get all the gene symbols and entrez IDs so you can put everything together\nlibrary(annotate)\nkeytypes(lumiMouseAll.db)\nmyGenesAll <- getSYMBOL(probeList, \"lumiMouseAll.db\")\nmyGenesAll <- as.matrix(myGenesAll)\nmyEntrezAll <- getEG(probeList, \"lumiMouseAll.db\")\nmyEntrezAll <- as.matrix(myEntrezAll)\nwrite.table(cbind(myGenesAll, myEntrezAll, filtered.matrix),\"normalizedFilteredData.txt\", sep=\"\\t\", quote=FALSE)\n\n###############################################################################################\n# also output unfiltered expression data.  \n###############################################################################################\nwrite.exprs(normData, file='robustSplineNorm.txt')\nnormData.delim <- read.delim(\"robustSplineNorm.txt\", header=TRUE, row.names=1)\nnormData.matrix <- as.matrix(normData.delim)\nprobeList2 <- rownames(normData.matrix)\nlibrary(annotate)\nsymbols <- getSYMBOL(probeList2, \"lumiMouseAll.db\")\nentrezIDs <- getEG(probeList2, \"lumiMouseAll.db\")\nwrite.table(cbind(symbols, entrezIDs, normData.matrix), \"unfiltered_expressionData.txt\", sep=\"\\t\", quote=FALSE)\n\n#goal of this script is to using multivariate statisical approaches to explore the structure of your data\n#begin by taking a look at the text expression matrix you created at the end of the last class\nhead(filtered.matrix)\n\n###############################################################################################\n# set up your experimental design by reading in a targets file that explains treatments, conditions, etc\n###############################################################################################\nlibrary(limma)\n#read in a tab-delimited \"targets\" file with the study design\ntargets <- readTargets(\"sunyerMouse_studyDesign.txt\", sep=\"\\t\")\ntargets\nmyGroups <- factor(paste(targets$cellType, targets$phenotype, sep=\".\"))\nmyGroups\ndesign <- model.matrix(~0+myGroups)\ncolnames(design) <- levels(myGroups)\ndesign\n\n\n###############################################################################################\n#carry out hierarchical clustering on filtered data\n###############################################################################################\n#make some sample labels \nsampleLabels <- paste(targets$cellType, targets$phenotype, targets$rep, sep=\".\")\ndistance <- dist(t(filtered.matrix),method=\"euclidean\")\nclusters <- hclust(distance, method = \"average\") \nplot(clusters, label = sampleLabels, hang = -1)\n\n\n###############################################################################################\n#Principal component analysis of the filtered data matrix\n###############################################################################################\npca.res <- prcomp(t(filtered.matrix), scale.=F, retx=T)\nls(pca.res)\nsummary(pca.res) # Prints variance summary for all principal components.\nhead(pca.res$rotation) #$rotation shows you how much each GENE influenced each PC (callled 'eigenvalues', or loadings)\nhead(pca.res$x) #$x shows you how much each SAMPLE influenced each PC (called 'scores')\nplot(pca.res, las=1)\npc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues\npc.per<-round(pc.var/sum(pc.var)*100, 1)\npc.per\n\n#make some graphs to visualize your PCA result\nlibrary(ggplot2)\n#lets first plot any two PCs against each other\n#turn your scores for each gene into a data frame\ndata.frame <- as.data.frame(pca.res$x)\nggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(myGroups))) +\n  geom_point(size=5) +\n  theme(legend.position=\"right\")\n\n#create a 'small multiples' chart to look at impact of each variable on each pricipal component\nlibrary(reshape2)\nmelted <- cbind(myGroups, melt(pca.res$x[,1:3]))\n#look at your 'melted' data\nggplot(melted) +\n  geom_bar(aes(x=Var1, y=value, fill=myGroups), stat=\"identity\") +\n  facet_wrap(~Var2)\n\n\n#this script walks thorough some basic data wrangling for organizing expression data spreadsheets and ends with\n#how to create publication quality graphics from transcriptomic data generated (regardless of platform used)\n#to start this script you need a file with all your expression data and some non-redundant identifiers as row names (usually gene symbols)\n#you also need a study design file\n\n#for creating graphics, we'll use the ggplot2 and ggvis packages which employ a 'grammar of graphics' approach\n#load the packages\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggvis)\n\n#read in your data from a text file that contains genes symbols as rows, and samples as columns. \nmyData <- read.delim(\"normalizedFilteredData.txt\", header=TRUE)\nhead(myData)\nmyData <- myData[,-2]\nrow.names(myData) <- myData[,1]\nmyData <- myData[,-1]\nhead(myData)\n\n#column headers a bit cumbersome, so we'll change these to something more human-readable\ntargets <- read.delim(\"SunyerMouse_studyDesign.txt\", sep=\"\\t\", stringsAsFactors = FALSE)\nsampleLabels <- as.character(paste(targets$cellType, targets$phenotype, targets$rep, sep=\".\"))\ncolnames(myData) <- sampleLabels\nhead(myData)\ngeneSymbols <- row.names(myData)\n\n#use the dplyr 'mutate' command to get averages and fold changes for all your replicates\nmyData <- mutate(myData,\n                 B1a.Naive.AVG = (B1a.naive.1 + B1a.naive.2)/2,\n                 B1b.Naive.AVG = (B1b.naive.1 + B1b.naive.2)/2,\n                 Mac.Naive.AVG = (Mac.naive.1 + Mac.naive.2)/2,\n                 B1a.Ph0.AVG = (B1a.Ph0.1 + B1a.Ph0.2)/2,\n                 B1a.nonPh0.AVG = (B1a.nonPh0.1 + B1a.nonPh0.2)/2,\n                 B1b.Ph0.AVG = (B1b.Ph0.1 + B1b.Ph0.2)/2,\n                 B1b.nonPh0.AVG = (B1b.nonPh0.1 + B1b.nonPh0.2)/2,\n                 Mac.Ph0.AVG = (Mac.Ph0.1 + Mac.Ph0.2)/2,\n                 LogFC.B1b.vs.B1a.naive = (B1b.Naive.AVG - B1a.Naive.AVG),\n                 LogFC.B1b.vs.Mac.naive = (B1b.Naive.AVG - Mac.Naive.AVG),\n                 LogFC.B1a.Ph0.vs.B1a.nonPh0 = (B1a.Ph0.AVG - B1a.nonPh0.AVG),\n                 LogFC.B1b.Ph0.vs.B1b.nonPh0 = (B1b.Ph0.AVG - B1b.nonPh0.AVG),\n                 LogFC.B1a.Ph0.vs.B1b.Ph0 = (B1a.Ph0.AVG - B1b.Ph0.AVG),\n                 geneSymbols = geneSymbols)\n\n#now look at this modified data table\nrow.names(myData) <- geneSymbols\nhead(myData)\n\n#use dplyr \"arrange\" and \"select\" functions to sort by LogFC column of interest (arrange)\n#and then display only the columns of interest (select) to see the most differentially expressed genes\nmyData.sort <- myData %>%\n  arrange(desc(LogFC.B1a.Ph0.vs.B1b.Ph0)) %>%\n  select(geneSymbols, LogFC.B1a.Ph0.vs.B1b.Ph0)\nhead(myData.sort)\nclass(geneSymbols)\n#use dplyr \"filter\" and \"select\" functions to pick out genes of interest (filter)\n#ways to tweek the 'select' function\n#use : between two column names to select all columns between\n#use 'contains', 'starts_with' or 'ends_with' to modify how you select\n#can refer to columns using exact name or numerical indicator\nmyData.filter <- myData %>%\n  filter(geneSymbols==\"Ccl3\" | geneSymbols==\"Ccl4\") %>%\n  select(geneSymbols, B1a.Naive.AVG, B1b.Naive.AVG, Mac.Naive.AVG) \nhead(myData.filter)\n\n#another example using grep to match patterns\nmyData.filter <- myData %>%\n  filter(grepl('Cxcl', geneSymbols)) %>%\n  select(geneSymbols, B1a.Naive.AVG, B1b.Naive.AVG, Mac.Naive.AVG) \nmyData.filter\n\n#first reorder and clean up the data you want to graph\nrow.names(myData.filter) <- myData.filter[,1]\nmyData.filter <- select(myData.filter, -geneSymbols)\nmyData.filter.transpose <- as.data.frame(t(myData.filter))\ncellType <- c(\"B1a\", \"B1b\", \"Mac\")\nmyData.filter.transpose <- mutate(myData.filter.transpose, cellType, \n                                  phenotype=c(\"naive\", \"naive\",\"naive\"))\nmyData.filter.transpose\n\n#plot a simple bar graph\nggplot(myData.filter.transpose, aes(y=Cxcl10)) +\n  geom_bar(aes(x=cellType, fill=phenotype), stat=\"identity\") +\n  theme(axis.text.x=element_text(angle=-45))\n\n#create a basic scatterplot using ggplot\nggplot(myData, aes(x=B1a.Ph0.AVG, y=Mac.Ph0.AVG)) +\n  geom_point(shape=1) +\n  geom_point(size=4)\n\n# ##Volcano plots\n# ##Highlight genes that have an absolute fold change > 2 and a p-value < Bonferroni cut-off\n# gene_list$threshold = as.factor(abs(gene_list$logFC) > 2 & gene_list$P.Value < 0.05/no_of_genes)\n# \n# ##Construct the volcano plot\n# ggplot(data=myData, aes(x=logFC, y=-log10(P.Value), colour=threshold)) +\n#   geom_point(alpha=0.4, size=1.75) +\n#   opts(legend.position = \"none\") +\n#   xlim(c(-10, 10)) + ylim(c(0, 15)) +\n#   xlab(\"log2 fold change\") + ylab(\"-log10 p-value\")\n\n#define a tooltip that shows gene symbol and Log2 expression data when you mouse over each data point in the plot\nlibrary(ggvis)\ntooltip <- function(data, ...) {\n  paste0(\"<b>\",\"Symbol: \", data$geneSymbols, \"</b><br>\",\n         \"B1a.Ph0.AVG: \", data$B1a.Ph0.AVG, \"<br>\",\n         \"B1a.nonPh0.AVG: \", data$B1a.nonPh0.AVG)\n}\n\n#plot the interactive graphic\nmyData %>% \n  ggvis(x= ~B1a.Ph0.AVG, y= ~B1a.nonPh0.AVG, key := ~geneSymbols) %>% \n  layer_points(fill = ~LogFC.B1a.Ph0.vs.B1a.nonPh0) %>%\n  add_tooltip(tooltip)\n\n#the goal of this script is to identify differentially expressed genes (DEG)\n#you should already know what pairwise comparisons are most important to you\n\n###############################################################################################\n# use Limma to find differentially expressed genes between two or more conditions\n###############################################################################################\n# fit the linear model to your filtered expression data\nlibrary(limma)\nfit <- lmFit(filtered.matrix, design)\n#add annotation into your linear model fit\n#don't really need to do this if you have RNAseq data\nlibrary(annotate)\nfit$genes$Symbol <- getSYMBOL(probeList, \"lumiMouseAll.db\")\nfit$genes$Entrez <- getEG(probeList, \"lumiMouseAll.db\")\n\n# set up a contrast matrix based on the pairwise comparisons of interest\ncontrast.matrix.naive <- makeContrasts(B1a_vs_B1b = B1a.naive - B1b.naive, Mac_vs_B1a = Mac.naive - B1a.naive, Mac_vs_B1b = Mac.naive - B1b.naive, levels=design)\ncontrast.matrix.Mac <- makeContrasts(Exposed_vs_naive = Mac.Ph0 - Mac.naive, Exposed_vs_B1aPh0 = Mac.Ph0 - B1a.Ph0, Exposed_vs_B1bPh0 = Mac.Ph0 - B1b.Ph0, levels=design)\ncontrast.matrix.B1a <- makeContrasts(Ph0_vs_naive = B1a.Ph0 - B1a.naive, nonPh0_vs_naive = B1a.nonPh0 - B1a.naive, Ph0_vs_nonPh0 = B1a.Ph0 - B1a.nonPh0, levels=design)\ncontrast.matrix.B1b <- makeContrasts(Ph0_vs_naive = B1b.Ph0 - B1b.naive, nonPh0_vs_naive = B1b.nonPh0 - B1b.naive, Ph0_vs_nonPh0 = B1b.Ph0 - B1b.nonPh0, levels=design)\ncontrast.matrix.B1a_and_B1b <- makeContrasts(Ph0_vs_naive = B1a.Ph0 - B1a.naive, nonPh0_vs_naive = B1a.nonPh0 - B1a.naive, Ph0_vs_nonPh0 = B1a.Ph0 - B1a.nonPh0, Ph0_vs_naive = B1b.Ph0 - B1b.naive, nonPh0_vs_naive = B1b.nonPh0 - B1b.naive, Ph0_vs_nonPh0 = B1b.Ph0 - B1b.nonPh0, levels=design)\ncontrast.matrix.Ph0 <- makeContrasts(B1a_vs_B1b = B1a.Ph0 - B1b.Ph0, levels=design)\ncontrast.matrix.nonPh0 <- makeContrasts(B1a_vs_B1b = B1a.nonPh0 - B1b.nonPh0, levels=design)\n\n# check each contrast matrix\ncontrast.matrix.naive\ncontrast.matrix.Mac\ncontrast.matrix.B1a\ncontrast.matrix.B1b\ncontrast.matrix.B1a_and_B1b\ncontrast.matrix.Ph0\ncontrast.matrix.nonPh0\n\n# extract the linear model fit for the contrast matrix that you just defined above\nfits.naive <- contrasts.fit(fit, contrast.matrix.naive)\nfits.Mac <- contrasts.fit(fit, contrast.matrix.Mac)\nfits.B1a <- contrasts.fit(fit, contrast.matrix.B1a)\nfits.B1b <- contrasts.fit(fit, contrast.matrix.B1b)\nfits.B1a_and_B1b <- contrasts.fit(fit, contrast.matrix.B1a_and_B1b)\nfits.Ph0 <- contrasts.fit(fit, contrast.matrix.Ph0)\nfits.nonPh0 <- contrasts.fit(fit, contrast.matrix.nonPh0)\n\nebFit.naive <- eBayes(fits.naive)\nebFit.Mac <- eBayes(fits.Mac)\nebFit.B1a <- eBayes(fits.B1a)\nebFit.B1b <- eBayes(fits.B1b)\nebFit.B1a_and_B1b <- eBayes(fits.B1a_and_B1b)\nebFit.Ph0 <- eBayes(fits.Ph0)\nebFit.nonPh0 <- eBayes(fits.nonPh0)\n\n\n###############################################################################################\n# use the topTable and decideTests functions to see the differentially expressed genes\n###############################################################################################\n\n# use topTable function to take a look at the hits\nprobeList.naive <- topTable(ebFit.naive, adjust =\"BH\", coef=1, number=50, sort.by=\"logFC\")\nprobeList.naive\nprobeList.Mac <- topTable(ebFit.Mac, adjust =\"BH\", coef=2, number=25, sort.by=\"logFC\")\nprobeList.Mac\nprobeList.B1a <- topTable(ebFit.B1a, adjust =\"BH\", coef=3, number=100, sort.by=\"logFC\")\nprobeList.B1a\nprobeList.B1b <- topTable(ebFit.B1b, adjust =\"BH\", coef=2, number=100, sort.by=\"logFC\")\nprobeList.B1b\nprobeList.Ph0 <- topTable(ebFit.Ph0, adjust =\"BH\", coef=1, number=25, sort.by=\"logFC\")\nprobeList.Ph0\nprobeList.nonPh0 <- topTable(ebFit.nonPh0, adjust =\"BH\", coef=1, number=25, sort.by=\"logFC\")\nprobeList.nonPh0\n\n# use the 'decideTests' function to show Venn diagram for all diffexp genes for up to three comparisons\nresults.naive <- decideTests(ebFit.naive, method=\"global\", adjust.method=\"BH\", p.value=0.01, lfc=1)\nresults.Mac <- decideTests(ebFit.Mac, method=\"global\", adjust.method=\"BH\", p.value=0.01, lfc=1)\nresults.B1a <- decideTests(ebFit.B1a, method=\"global\", adjust.method=\"BH\", p.value=0.01, lfc=1)\nresults.B1b <- decideTests(ebFit.B1b, method=\"global\", adjust.method=\"BH\", p.value=0.01, lfc=1)\nresults.B1a_and_B1b <- decideTests(ebFit.B1a_and_B1b, method=\"global\", adjust.method=\"BH\", p.value=0.01, lfc=1)\nresults.Ph0 <- decideTests(ebFit.Ph0, method=\"global\", adjust.method=\"BH\", p.value=0.05, lfc=0.59)\nresults.nonPh0 <- decideTests(ebFit.nonPh0, method=\"global\", adjust.method=\"BH\", p.value=0.05, lfc=0.59)\n\nvennDiagram(results.B1a, include=\"both\") #all pairwise comparisons on a B6 background\n\n# retrieve gene symbols for the probes from above\ndiffSymbols.naive <- fit$genes$Symbol[results.naive[,1] !=0 | results.naive[,2] !=0 | results.naive[,3] !=0]\ndiffSymbols.B1a <- fit$genes$Symbol[results.B1a[,1] !=0 | results.B1a[,2] !=0 | results.B1a[,3] !=0]\ndiffSymbols.B1b <- fit$genes$Symbol[results.B1b[,1] !=0 | results.B1b[,2] !=0 | results.B1b[,3] !=0]\n\n\n# retrieve entrez IDs for the probes from above\ndiffEntrez.naive <- fit$genes$Entrez[results.naive[,1] !=0 | results.naive[,2] !=0 | results.naive[,3] !=0]\ndiffEntrez.B1a <- fit$genes$Entrez[results.B1a[,1] !=0 | results.B1a[,2] !=0 | results.B1a[,3] !=0]\ndiffEntrez.B1b <- fit$genes$Entrez[results.B1b[,1] !=0 | results.B1b[,2] !=0 | results.B1b[,3] !=0]\n\n\n# retrieve expression data for the probes from above\nfiltered.matrix.eset <- new(\"ExpressionSet\", exprs = filtered.matrix)\ndiffData.naive <- filtered.matrix.eset[results.naive[,1] !=0 | results.naive[,2] !=0 | results.naive[,3] !=0]\ndiffData.naive <- exprs(diffData.naive)\ndiffData.B1a <- filtered.matrix.eset[results.B1a[,1] !=0 | results.B1a[,2] !=0 | results.B1a[,3] !=0]\ndiffData.B1a <- exprs(diffData.B1a)\ndiffData.B1b <- filtered.matrix.eset[results.B1b[,1] !=0 | results.B1b[,2] !=0 | results.B1b[,3] !=0]\ndiffData.B1b <- exprs(diffData.B1b)\n#write out your differentially expressed genes\nwrite.table(cbind(diffSymbols.naive, diffEntrez.naive, diffData.naive), \"myDEGs_naive.xls\", sep=\"\\t\", quote=FALSE)\nwrite.table(cbind(diffSymbols.B1a, diffEntrez.B1a, diffData.B1a), \"myDEGs_B1a.xls\", sep=\"\\t\", quote=FALSE)\nwrite.table(cbind(diffSymbols.B1b, diffEntrez.B1b, diffData.B1b), \"myDEGs_B1b.xls\", sep=\"\\t\", quote=FALSE)\n\n\n#this script creates detailed heatmaps from your differentially expressed genes\n#first part of script contains basic heatmap creation by reading in a file of a priori genes\n#second part of script uses all the differentially expressed genes you identified previously\n\n###################################################################################################\n# generate a heatmap of differentially expressed transcripts using the entire dataset\n###################################################################################################\nhr <- hclust(as.dist(1-cor(t(diffData.AVG.subset), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(diffData.AVG.subset, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\nmycl <- cutree(hr, k=2)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\n\n#plot the hclust results as a heatmap\nheatmap.2(diffData.AVG.subset, Rowv=as.dendrogram(hr), Colv=NA, \n          col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          cexRow=1, cexCol=1, margins=c(8,30)) \n\n#notice that the heatmap includes ALL the columns from your dataset\n#lets fix this so that we are only showing appropriate columns \ndiffData.B1a.subset <- diffData.B1a[,c(1,2,7,8,9,10)]\n#now repeat heatmap only on these selected columns\nnames(mycolhc) <- names(mycl) \nbarplot(rep(10, max(mycl)), \n        col=unique(mycolhc[hr$labels[hr$order]]), \n        horiz=T, names=unique(mycl[hr$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\n\n#Now repeat this process, but with your biological replicates averaged\n#then rerun the heatmap the script above using diffData.AVG as input instead of diffData\nlibrary(limma)\ncolnames(diffData.B1a) <- myGroups\nrownames(diffData.B1a) <- diffSymbols.B1a\nhead(diffData.B1a)\ndiffData.AVG <- avearrays(diffData.B1a)\nhead(diffData.AVG)\ndim(diffData.AVG)\ndiffData.AVG.subset <- diffData.AVG[,c(1,4,5)]\n###############################################################################################\n#select sub-clusters of co-regulated transcripts for downstream analysis\n###############################################################################################\nlibrary(annotate)\nlibrary(lumiMouseAll.db)\nclid <- c(2) \nysub <- diffData.AVG.subset[names(mycl[mycl%in%clid]),] \nhrsub <- hclust(as.dist(1-cor(t(ysub), method=\"pearson\")), method=\"complete\") \nclusterIDs <- data.frame(Labels=rev(hrsub$labels[hrsub$order]))\nclusterIDs <- as.vector(t(clusterIDs))\nheatmap.2(ysub, Rowv=as.dendrogram(hrsub), Colv=NA, col=myheatcol, scale=\"row\", labRow=getSYMBOL(clusterIDs, \"lumiMouseAll.db\"), labCol=sampleLabels, density.info=\"none\", trace=\"none\", RowSideColors=mycolhc[mycl%in%clid], margins=c(8,30)) # Create heatmap for chosen sub-cluster.\n\n#retrieve gene symbols and entrezIDs for selected cluster and print out to an excel spreadsheet for downstream applications (i.e. GO enrichment in DAVID)\nmyCluster <- cbind(getSYMBOL(clusterIDs, \"lumiMouseAll.db\"), getEG(clusterIDs, \"lumiMouseAll.db\"))\nwrite.table(myCluster, \"Cluster7.txt\", sep=\"\\t\", quote=FALSE)\n\n###############################################################################################\n#read in your own data to make a heatmap\n###############################################################################################\nmySelected <- read.delim(\"WTvsPHIL_selected.txt\", sep=\"\\t\", stringsAsFactors = FALSE, header=TRUE, row.names=1)\nmySelected.matrix <- as.matrix(mySelected)\n#carry out hclust on the collapsed data matrix to generate a distance matrix for clustering\nheatmap.2(mySelected.matrix, Rowv=NA, Colv=NA, col=myheatcol, scale=\"row\", density.info=\"none\", trace=\"none\", labCol=NA, cexRow=1.5, cexCol=1, margins=c(20,28), key = F) # Creates heatmap for entire data set where the obtained clusters are indicated in the color bar.\n\n###################################################################\n#another way to make a simple heatmap is to read in a file with expression data\n###################################################################\nmyData <- read.delim(\"balelab_miR_diff2foldFDR.txt\", sep=\"\\t\", stringsAsFactors = FALSE, header=TRUE, row.names=1)\nclass(myData)\nhead(myData)\nmyData.matrix <- as.matrix(myData)\n#carry out hclust on the collapsed data matrix to generate a distance matrix for clustering\nhr <- hclust(as.dist(1-cor(t(myData.matrix), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(myData.matrix, method=\"spearman\")), method=\"average\") #cluster columns by spearman correlation\n\n###############################################################################################\n#yet another way is to first generate a table using dplyr 'filter' and 'select' to get table for heatmap\n###############################################################################################\nmyData.filter <- myData %>%\n  filter((abs(Ecdysone.vs.PBS_18hr_gut) >= 1) | (abs(Ecdysone.vs.PBS_5hr_gut) >= 1)) %>%\n  select(geneID, Ecdysone.vs.PBS_5hr_carcass, Ecdysone.vs.PBS_18hr_carcass, Ecdysone.vs.PBS_5hr_gut, Ecdysone.vs.PBS_18hr_gut)\nhead(myData.filter)\nrownames(myData.filter) <- myData.filter[,1]\nmyData.filter <- as.matrix(myData.filter[,-1])\nhr <- hclust(as.dist(1-cor(t(myData.filter), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(myData.filter, method=\"spearman\")), method=\"average\") #cluster columns by spearman correlation\nheatmap.2(myData.filter, Rowv=NA, Colv=NA, col=myheatcol, scale=\"row\", density.info=\"none\", trace=\"none\", labCol=NA, cexRow=1.5, cexCol=1, margins=c(20,28), key = F) # Creates heatmap for entire data set where the obtained clusters are indicated in the color bar.\n\n\n\n\n\n\n\n\n\n",
    "created" : 1433293345503.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2966982785",
    "id" : "34132DE1",
    "lastKnownWriteTime" : 1432764773,
    "path" : "~/Git/TranscriptomicsWorkshop.github.io/R_scripts/myAnalysis.R",
    "project_path" : "myAnalysis.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}