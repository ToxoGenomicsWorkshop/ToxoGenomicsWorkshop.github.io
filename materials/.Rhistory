#annotate your normalized data using the organism-specific database package
##############################################################################################################################
library(org.Tgondii.eg.db)
library(AnnotationDbi)
#If we want to know what kinds of data are retriveable via the 'select' command, look at the columns of the annotation database
head(exprs.matrix.filtered)
cols.ALL <- topo.colors (n=18, alpha=1)
hist(rpkm.filtered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(rpkm.filtered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
distance <- dist(t(rpkm.filtered),method="euclidean") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
?duplicateCorrelation
batch <- factor(targets$batch)
batch
targets$batch
targets
targets <- read.delim("studyDesign.alt.txt", row.names=NULL)
targets
batch <- factor(targets$batch)
batch
fit <- lmFit(rpkm.filtered, block = biolrep, cor = corfit$consensus)
fit <- lmFit(rpkm.filtered, block = batch, cor = corfit$consensus)
corfit <- duplicateCorrelation(rpkm.filtered, design=design, block = batch)
library(limma)
batch <- factor(targets$batch)
corfit <- duplicateCorrelation(rpkm.filtered, design=design, block = batch)
install.packages("statmod")
corfit <- duplicateCorrelation(rpkm.filtered, design=design, block = batch)
corfit
corfit$consensus
fit <- lmFit(rpkm.filtered, block = batch, cor = corfit$consensus)
fit <- eBayes(fit)
topTable(fit, adjust = "BH")
distance <- dist(t(rpkm.filtered),method="euclidean") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
targets
pair <- factor(targets$block)
pair
pair <- factor(targets$batch)
pair
design2 <- model.matrix(~groups+pair)
design2
design2 <- model.matrix(~0+groups+pair)
design2
groups <- factor(paste(targets$strain, targets$stage, sep="."))
batch <- factor(targets$rep)
batch
sampleLabels <- paste(targets$strain, targets$stage, targets$rep, sep=".")
sampleLabels
design2 <- model.matrix(~batch+groups)
design2
normData.unfiltered <- voom(DGEList, design2, plot=TRUE)
colnames(resultTable.filtered)
setwd("~/Git/ToxoGenomicsWorkshop.github.io/materials")
library(Rsubread)
library(limma)
library(edgeR)
library(ShortRead)
options(digits=2)
#library(Biostrings)
#read in your study design file
targets <- read.delim("studyDesign.txt", row.names=NULL)
targets
groups <- factor(paste(targets$strain, targets$stage, sep="."))
batch <- factor(targets$rep)
#create some more human-readable labels for your samples using the info in this file
sampleLabels <- paste(targets$strain, targets$stage, targets$rep, sep=".")
DGEList <- DGEList(counts=fc$counts, genes=fc$annotation)
save(DGEList, file="DGEList")
load("DGEList")
#retrieve all your gene/transcript identifiers from this DGEList object
myGeneIDs <- DGEList$genes$GeneID
##############################################################################################################################
#Normalize unfiltered data using 'voom' function in Limma package
#This will normalize based on the mean-variance relationship
#will also generate the log2 of counts per million based on the size of each library (also a form of normalization)
##############################################################################################################################
normData.unfiltered <- voom(DGEList, design2, plot=TRUE)
exprs.unfiltered <- normData.unfiltered$E
exprs.matrix.unfiltered <- as.matrix(exprs.unfiltered)
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.matrix.unfiltered)
#if you need RPKM for your unfiltered, they can generated as follows
#Although RPKM are commonly used, not really necessary since you don't care to compare two different genes within a sample
rpkm.unfiltered <- rpkm(DGEList, DGEList$genes$Length)
rpkm.unfiltered <- log2(rpkm.unfiltered + 1)
##############################################################################################################################
#Filtering your dataset and normalize this
#Only keep in the analysis those genes which had >10 reads per million mapped reads in at least two libraries.
##############################################################################################################################
cpm.matrix.filtered <- rowSums(cpm(DGEList) > 10) >= 2
DGEList.filtered <- DGEList[cpm.matrix.filtered,]
dim(DGEList.filtered)
normData.filtered <- voom(DGEList.filtered, design2, plot=TRUE)
exprs.filtered <- normData.filtered$E
exprs.matrix.filtered <- as.matrix(exprs.filtered)
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.matrix.filtered)
rpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here
rpkm.filtered <- log2(rpkm.filtered + 1)
###############################################################################################
#explore your data using some standard approaches
cols.ALL <- topo.colors (n=18, alpha=1)
hist(rpkm.filtered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(rpkm.filtered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
distance <- dist(t(rpkm.filtered),method="euclidean") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
colnames(exprs.matrix.filtered)
head(exprs.matrix.filtered)
colnames(resultTable.filtered) <- sampleLabels
colnames(exprs.matrix.filtered) <- sampleLabels
colnames(exprs.matrix.filtered)
myData <- mutate(exprs.matrix.filtered,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
myData <- mutate(exprs.matrix.filtered,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG))
library(ggplot2)
library(dplyr)
library(ggvis)
myData <- mutate(exprs.matrix.filtered,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG))
class(exprs.filtered)
myData <- mutate(exprs.matrix.filtered,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG))
exprs.filtered.datafram <- as.data.frame(exprs.filtered)
exprs.filtered.dataframe <- as.data.frame(exprs.filtered)
myData <- mutate(exprs.filtered.dataframe,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG))
#use dplyr "arrange" and "select" functions to sort by LogFC column of interest (arrange)
#and then display only the columns of interest (select) to see the most differentially expressed genes
exprs.filtered.dataframe <- as.data.frame(exprs.filtered)
colnames(exprs.filtered.dataframe)
head(exprs.filtered.dataframe)
colnames(exprs.filtered.dataframe) <- sampleLabels
#use the dplyr 'mutate' command to get averages and fold changes for all your replicates
myData <- mutate(exprs.filtered.dataframe,
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG))
myData
head(myData)
myData <- mutate(exprs.filtered.dataframe,
#insert columns that average your replicates
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (RH.brady.rep1 + RH.brady.rep2 + RH.brady.rep3)/2,
PLK.brady.AVG = (PLK.brady.rep1 + PLK.brady.rep2 + PLK.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
#now add fold-change columns based on the averages calculated above
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG))
#take a look at your new spreadsheet
head(myData)
myData.sort <- myData %>%
arrange(desc(CTG.vs.RH.tachy)) %>%
select(RH.tachy.AVG, PLK.tachy.AVG, CTG.brady.AVG)
head(myData.sort)
head(exprs.filtered.dataframe)
geneID <- rownames(exprs.filtered.dataframe)
myData.sort <- myData %>%
arrange(desc(CTG.vs.RH.tachy)) %>%
select(geneID, RH.tachy.AVG, PLK.tachy.AVG, CTG.brady.AVG)
head(myData.sort)
myData <- mutate(exprs.filtered.dataframe,
#insert columns that average your replicates
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (RH.brady.rep1 + RH.brady.rep2 + RH.brady.rep3)/2,
PLK.brady.AVG = (PLK.brady.rep1 + PLK.brady.rep2 + PLK.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
#now add fold-change columns based on the averages calculated above
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG),
geneID))
myData <- mutate(exprs.filtered.dataframe,
#insert columns that average your replicates
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (RH.brady.rep1 + RH.brady.rep2 + RH.brady.rep3)/2,
PLK.brady.AVG = (PLK.brady.rep1 + PLK.brady.rep2 + PLK.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
#now add fold-change columns based on the averages calculated above
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG),
geneID)
#take a look at your new spreadsheet
head(myData)
#use dplyr "arrange" and "select" functions to sort by LogFC column of interest (arrange)
#and then display only the columns of interest (select) to see the most differentially expressed genes
myData.sort <- myData %>%
arrange(desc(CTG.vs.RH.tachy)) %>%
select(geneID, RH.tachy.AVG, PLK.tachy.AVG, CTG.brady.AVG)
head(myData.sort)
myData.sort <- myData %>%
arrange(desc(brady.vs.tachy.PLK)) %>%
select(geneID, PLK.tachy.AVG, PLK.brady.AVG)
head(myData.sort)
targets <- read.delim("studyDesign.txt", row.names=NULL)
targets
groups <- factor(paste(targets$strain, targets$stage, sep="."))
batch <- factor(targets$rep)
batch
design <- model.matrix(~0+groups)
design2 <- model.matrix(~batch+groups)
colnames(design) <- levels(groups)
design
design2
myBAM <- targets$output
myBAM
myGeneIDs <- DGEList$genes$GeneID
myGeneIDs
batch
normData.unfiltered <- voom(DGEList, design2, plot=TRUE)
exprs.unfiltered <- normData.unfiltered$E
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.unfiltered)
#if you need RPKM for your unfiltered, they can generated as follows
#Although RPKM are commonly used, not really necessary since you don't care to compare two different genes within a sample
rpkm.unfiltered <- rpkm(DGEList, DGEList$genes$Length)
rpkm.unfiltered <- log2(rpkm.unfiltered + 1)
##############################################################################################################################
#Filtering your dataset and normalize this
#Only keep in the analysis those genes which had >10 reads per million mapped reads in at least two libraries.
##############################################################################################################################
cpm.matrix.filtered <- rowSums(cpm(DGEList) > 10) >= 2
DGEList.filtered <- DGEList[cpm.matrix.filtered,]
dim(DGEList.filtered)
normData.filtered <- voom(DGEList.filtered, design2, plot=TRUE)
exprs.filtered <- normData.filtered$E
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.filtered)
rpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here
rpkm.filtered <- log2(rpkm.filtered + 1)
###############################################################################################
#explore your data using some standard approaches
###############################################################################################
#choose color scheme for graphs
cols.ALL <- topo.colors (n=18, alpha=1)
hist(rpkm.filtered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(rpkm.filtered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
distance <- dist(t(rpkm.filtered),method="euclidean") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
hist(exprs.unfiltered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(exprs.unfiltered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
hist(exprs.filtered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(exprs.filtered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
distance <- dist(t(exprs.filtered),method="euclidean") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
distance <- dist(t(exprs.filtered),method="maximum") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
distance <- dist(t(exprs.filtered),method="maximum") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "complete") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
distance <- dist(t(exprs.filtered),method="maximum") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
pca.res <- prcomp(t(exprs.filtered), scale.=F, retx=T)
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
head(pca.res$rotation) #$rotation shows you how much each GENE influenced each PC (callled 'eigenvalues', or loadings)
head(pca.res$x) #$x shows you how much each SAMPLE influenced each PC (called 'scores')
plot(pca.res, las=1)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
#make some graphs to visualize your PCA result
library(ggplot2)
#lets first plot any two PCs against each other
#turn your scores for each gene into a data frame
data.frame <- as.data.frame(pca.res$x)
ggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(myGroups))) +
geom_point(size=5) +
theme(legend.position="right")
ggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(Groups))) +
geom_point(size=5) +
theme(legend.position="right")
ggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(groups))) +
geom_point(size=5) +
theme(legend.position="right")
#create a 'small multiples' chart to look at impact of each variable on each pricipal component
library(reshape2)
melted <- cbind(myGroups, melt(pca.res$x[,1:3]))
library(reshape2)
melted <- cbind(groups, melt(pca.res$x[,1:3]))
#look at your 'melted' data
ggplot(melted) +
geom_bar(aes(x=Var1, y=value, fill=myGroups), stat="identity") +
facet_wrap(~Var2)
ggplot(melted) +
geom_bar(aes(x=Var1, y=value, fill=groups), stat="identity") +
facet_wrap(~Var2)
pc.per
exprs.filtered.dataframe <- as.data.frame(exprs.filtered)
colnames(exprs.filtered.dataframe)
head(exprs.filtered.dataframe)
colnames(exprs.filtered.dataframe) <- sampleLabels
geneID <- rownames(exprs.filtered.dataframe)
#use the dplyr 'mutate' command to get averages and fold changes for all your replicates
myData <- mutate(exprs.filtered.dataframe,
#insert columns that average your replicates
RH.tachy.AVG = (RH.tachy.rep1 + RH.tachy.rep2 + RH.tachy.rep3)/2,
PLK.tachy.AVG = (PLK.tachy.rep1 + PLK.tachy.rep2 + PLK.tachy.rep3)/2,
CTG.tachy.AVG = (CTG.tachy.rep1 + CTG.tachy.rep2 + CTG.tachy.rep3)/2,
RH.brady.AVG = (RH.brady.rep1 + RH.brady.rep2 + RH.brady.rep3)/2,
PLK.brady.AVG = (PLK.brady.rep1 + PLK.brady.rep2 + PLK.brady.rep3)/2,
CTG.brady.AVG = (CTG.brady.rep1 + CTG.brady.rep2 + CTG.brady.rep3)/2,
#now add fold-change columns based on the averages calculated above
PLK.vs.RH.tachy = (PLK.tachy.AVG - RH.tachy.AVG),
CTG.vs.RH.tachy = (CTG.tachy.AVG - RH.tachy.AVG),
PLK.vs.CTG.tachy = (PLK.tachy.AVG - CTG.tachy.AVG),
brady.vs.tachy.RH = (RH.brady.AVG - RH.tachy.AVG),
brady.vs.tachy.PLK = (PLK.brady.AVG - PLK.tachy.AVG),
brady.vs.tachy.CTG = (CTG.brady.AVG - CTG.tachy.AVG),
geneID)
#take a look at your new spreadsheet
head(myData)
library(limma)
fit <- lmFit(exprs.filtered, design)
fit2 <- lmFit(exprs.filtered, design2)
#add annotation into your linear model fit
#don't really need to do this if you have RNAseq data
design2
contrast.matrix.tachy <- makeContrasts(RHvsCTG = groupsRH.tachy - groupsCTG.tachy, RHvsPLK = groupsRH.tachy - groupsPLK.brady, CTGvsPLK = groupsCTG.tachy - groupsPLK.brady, levels=design2)
contrast.matrix.tachy
fits <- contrasts.fit(fit2, contrast.matrix.tachy)
groups
design
colnames(design2)
fit <- lmFit(exprs.filtered, design)
#fit2 <- lmFit(exprs.filtered, design2)
# set up a contrast matrix based on the pairwise comparisons of interest
contrast.matrix.tachy <- makeContrasts(RHvsCTG = RH.tachy - CTG.tachy, RHvsPLK = RH.tachy - PLK.brady, CTGvsPLK = CTG.tachy - PLK.brady, levels=design)
contrast.matrix.strains <- makeContrasts(RHvsCTG = RH.tachy - CTG.tachy, RHvsPLK = RH.tachy - PLK.brady, CTGvsPLK = CTG.tachy - PLK.brady, levels=design)
# check each contrast matrix
contrast.matrix.strains
fits <- contrasts.fit(fit1, contrast.matrix.strains)
fits <- contrasts.fit(fit, contrast.matrix.strains)
#get bayesian stats for your linear model fit
ebFit <- eBayes(fits)
###############################################################################################
# use the topTable and decideTests functions to see the differentially expressed genes
###############################################################################################
# use topTable function to take a look at the hits
myTopHits <- topTable(ebFit, adjust ="BH", coef=1, number=50, sort.by="logFC")
myTopHits
# use the 'decideTests' function to show Venn diagram for all diffexp genes for up to three comparisons
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.05, lfc=0.59)
#stats <- write.fit(ebFit)
vennDiagram(results, include="both") #all pairwise comparisons on a B6 background
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=1)
#stats <- write.fit(ebFit)
vennDiagram(results, include="both") #all pairwise comparisons on a B6 background
diffProbes <- which(results[,1] !=0 | results[,2] !=0 | results[,3] !=0)
diffSymbols <- fit$genes$Symbol[results[,1] !=0 | results[,2] !=0 | results[,3] !=0]
diffEntrez <- fit$genes$Entrez[results[,1] !=0 | results[,2] !=0 | results[,3] !=0]
diffSymbols
diffEntrez
diffGenes <- which(results[,1] !=0 | results[,2] !=0 | results[,3] !=0)
diffGenes
diffData <- exprs.filtered[results[,1] !=0 | results[,2] !=0 | results[,3] !=0]
diffData
write.table(cbind(diffGenes, diffData),"DiffGenes.xls", sep="\t", quote=FALSE)
dim(diffData)
save(DGEList, file="DGEList")
##############################################################################################################################
#beginning of Toxo13 Genomics Workshop
##############################################################################################################################
load("DGEList")
#retrieve all your gene/transcript identifiers from this DGEList object
myGeneIDs <- DGEList$genes$GeneID
##############################################################################################################################
#Normalize unfiltered data using 'voom' function in Limma package
#This will normalize based on the mean-variance relationship
#will also generate the log2 of counts per million based on the size of each library (also a form of normalization)
##############################################################################################################################
normData.unfiltered <- voom(DGEList, design2, plot=TRUE)
exprs.unfiltered <- normData.unfiltered$E
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.unfiltered)
#if you need RPKM for your unfiltered, they can generated as follows
#Although RPKM are commonly used, not really necessary since you don't care to compare two different genes within a sample
rpkm.unfiltered <- rpkm(DGEList, DGEList$genes$Length)
rpkm.unfiltered <- log2(rpkm.unfiltered + 1)
##############################################################################################################################
#Filtering your dataset and normalize this
#Only keep in the analysis those genes which had >10 reads per million mapped reads in at least two libraries.
##############################################################################################################################
cpm.matrix.filtered <- rowSums(cpm(DGEList) > 10) >= 2
DGEList.filtered <- DGEList[cpm.matrix.filtered,]
dim(DGEList.filtered)
normData.filtered <- voom(DGEList.filtered, design2, plot=TRUE)
exprs.filtered <- normData.filtered$E
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
head(exprs.filtered)
rpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here
rpkm.filtered <- log2(rpkm.filtered + 1)
###############################################################################################
#explore your data using some standard approaches
###############################################################################################
#choose color scheme for graphs
cols.ALL <- topo.colors (n=18, alpha=1)
hist(exprs.filtered, xlab = "log2 expression", main = "normalized data - histograms", col=cols.ALL)
boxplot(exprs.filtered, ylab = "normalized log2 expression", main = "non-normalized data - boxplots", col=cols.ALL)
distance <- dist(t(exprs.filtered),method="maximum") # options for computing distance matrix are: "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski".
clusters <- hclust(distance, method = "average") #options for clustering method: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid".
plot(clusters, label=sampleLabels)
pca.res <- prcomp(t(exprs.filtered), scale.=F, retx=T)
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
head(pca.res$rotation) #$rotation shows you how much each GENE influenced each PC (callled 'eigenvalues', or loadings)
head(pca.res$x) #$x shows you how much each SAMPLE influenced each PC (called 'scores')
plot(pca.res, las=1)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
#make some graphs to visualize your PCA result
library(ggplot2)
#lets first plot any two PCs against each other
#turn your scores for each gene into a data frame
data.frame <- as.data.frame(pca.res$x)
ggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(groups))) +
geom_point(size=5) +
theme(legend.position="right")
library(reshape2)
melted <- cbind(groups, melt(pca.res$x[,1:3]))
#look at your 'melted' data
ggplot(melted) +
geom_bar(aes(x=Var1, y=value, fill=groups), stat="identity") +
facet_wrap(~Var2)
pc.per
load("DGEList")
#retrieve all your gene/transcript identifiers from this DGEList object
myGeneIDs <- DGEList$genes$GeneID
##############################################################################################################################
#Normalize unfiltered data using 'voom' function in Limma package
#This will normalize based on the mean-variance relationship
#will also generate the log2 of counts per million based on the size of each library (also a form of normalization)
